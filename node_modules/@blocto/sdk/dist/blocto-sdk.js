/* Version: 0.10.2 - May 3, 2024 04:32:27 */
'use strict';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// instead invariant from package, since all error will throw on production
function invariant(condition, format) {
    if (!condition) {
        throw new Error(format);
    }
}

var KEY_SESSION;
(function (KEY_SESSION) {
    KEY_SESSION["prod"] = "BLOCTO_SDK";
    KEY_SESSION["dev"] = "BLOCTO_SDK_DEV";
    KEY_SESSION["staging"] = "BLOCTO_SDK_STAGING";
})(KEY_SESSION || (KEY_SESSION = {}));
var CHAIN;
(function (CHAIN) {
    CHAIN["ETHEREUM"] = "ethereum";
    CHAIN["APTOS"] = "aptos";
})(CHAIN || (CHAIN = {}));
/* eth series constants begin */
const ETH_RPC_LIST = {
    // This is the list of public RPC endpoints that we known to be working
    // Used to help developers did not set up their own RPC endpoints
    // BSC mainnet
    56: 'https://bsc-dataseed1.binance.org',
    // BSC testnet
    97: 'https://data-seed-prebsc-1-s1.binance.org:8545',
    // Polygon Mainnet
    137: 'https://rpc-mainnet.maticvigil.com/',
    // Polygon Amoy Testnet
    80002: 'https://rpc-amoy.polygon.technology/',
    // Avalanche Mainnet
    43114: 'https://api.avax.network/ext/bc/C/rpc',
    // Avalanche Fuji Testnet
    43113: 'https://api.avax-test.network/ext/bc/C/rpc',
    // Arbitrum Mainnet
    42161: 'https://arb1.arbitrum.io/rpc',
    // Arbitrum Sepolia Testnet
    421614: 'https://arbitrum-sepolia.blockpi.network/v1/rpc/public',
    // Optimism Mainnet
    10: 'https://mainnet.optimism.io',
    // Optimism Sepolia Testnet
    11155420: 'https://sepolia.optimism.io',
    // Base Mainnet
    8453: 'https://mainnet.base.org',
    // Base Sepolia Testnet
    84532: 'https://sepolia.base.org',
    // Zora
    7777777: 'https://rpc.zora.energy',
    // Zora Sepolia Testnet
    999999999: 'https://sepolia.rpc.zora.energy',
    // Scroll
    534352: 'https://rpc.scroll.io',
    // Scroll Sepolia Testnet
    534351: 'https://sepolia-rpc.scroll.io',
    // Linea
    59144: 'https://rpc.linea.build',
    // zKatana Sepolia Testnet
    1261120: 'https://rpc.startale.com/zkatana',
    // Blast
    81457: 'https://rpc.blast.io',
    // Blast Sepolia Testnet
    168587773: 'https://sepolia.blast.io'
};
const ETH_ENV_WALLET_SERVER_MAPPING = {
    prod: 'https://wallet-v2.blocto.app',
    staging: 'https://wallet-v2-staging.blocto.app',
    dev: 'https://wallet-v2-dev.blocto.app',
};
const ETH_SESSION_KEY_MAPPING = {
    prod: KEY_SESSION.prod,
    staging: KEY_SESSION.staging,
    dev: KEY_SESSION.dev,
};
/* eth series constants end */
/* aptos constants begin */
const APT_SESSION_KEY_MAPPING = {
    1: KEY_SESSION.prod,
    2: KEY_SESSION.dev,
    3: KEY_SESSION.dev,
    4: KEY_SESSION.dev,
    5: KEY_SESSION.staging,
};
const APT_CHAIN_ID_SERVER_MAPPING = {
    // MAINNET
    1: 'https://wallet-v2.blocto.app',
    // TESTNET
    2: 'https://wallet-v2-dev.blocto.app',
    // DEVNET
    3: 'https://wallet-v2-dev.blocto.app',
    // TESTING
    4: 'https://wallet-v2-dev.blocto.app',
    // PREMAINNET
    5: 'https://wallet-v2-staging.blocto.app',
};
var WalletAdapterNetwork;
(function (WalletAdapterNetwork) {
    WalletAdapterNetwork["Mainnet"] = "mainnet";
    WalletAdapterNetwork["Testnet"] = "testnet";
    WalletAdapterNetwork["Devnet"] = "devnet";
    WalletAdapterNetwork["Testing"] = "testing";
    WalletAdapterNetwork["Premainnet"] = "premainnet";
})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));
const APT_CHAIN_ID_NAME_MAPPING = {
    1: WalletAdapterNetwork.Mainnet,
    2: WalletAdapterNetwork.Testnet,
    3: WalletAdapterNetwork.Devnet,
    4: WalletAdapterNetwork.Testing,
    5: WalletAdapterNetwork.Premainnet,
};
const APT_CHAIN_ID_RPC_MAPPING = {
    1: 'https://fullnode.mainnet.aptoslabs.com/v1',
    2: 'https://fullnode.testnet.aptoslabs.com/v1',
    3: 'https://fullnode.devnet.aptoslabs.com/v1',
    4: '',
    5: 'https://premainnet.aptosdev.com/v1',
};
/* aptos constants end */
const EIP1193_EVENTS = [
    'connect',
    'disconnect',
    'message',
    'chainChanged',
    'accountsChanged',
];
// Preserve login for 1 day
const LOGIN_PERSISTING_TIME = 86400 * 1000;
const DEFAULT_APP_ID = '00000000-0000-0000-0000-000000000000';
// Will inject the version of the SDK by rollup versionInjector during build time
const SDK_VERSION = '0.10.2';

// The root class for all providers
class BloctoProvider {
    constructor() {
        this.isBlocto = true;
        this.isConnecting = false;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.eventListeners = {};
        // alias removeListener
        this.off = this.removeListener;
        // init event listeners
        EIP1193_EVENTS.forEach((event) => {
            this.eventListeners[event] = [];
        });
        this.appId = DEFAULT_APP_ID;
    }
    // implement by children
    // eslint-disable-next-line
    request(payload) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    on(event, listener) {
        if (!EIP1193_EVENTS.includes(event))
            return;
        this.eventListeners[event].push(listener);
    }
    // @todo: implement it
    // eslint-disable-next-line
    once() { }
    removeListener(event, listener) {
        const listeners = this.eventListeners[event];
        const index = listeners.findIndex((item) => item === listener);
        if (index !== -1) {
            this.eventListeners[event].splice(index, 1);
        }
    }
}

const IFRAME_STYLE = 'width:100vw;height:100%;position:fixed;top:0;left:0;z-index:2147483646;border:none;box-sizing:border-box;color-scheme:light;inset:0px;display:block;pointer-events:auto;';
function createFrame(url) {
    const frame = document.createElement('iframe');
    frame.setAttribute('src', url);
    frame.setAttribute('style', IFRAME_STYLE);
    return frame;
}
function attachFrame(frame) {
    document.body.appendChild(frame);
}
function detatchFrame(frame) {
    const parentNode = frame && frame.parentNode;
    if (parentNode && parentNode.removeChild instanceof Function) {
        parentNode.removeChild(frame);
    }
}

var addSelfRemovableHandler = (eventType, handler, target = window) => {
    function listener(e) {
        const removeEventListener = () => target.removeEventListener(eventType, listener);
        handler(e, removeEventListener);
    }
    target.addEventListener(eventType, listener);
};

const isStorageSupported = () => {
    if (typeof window === 'undefined') {
        return false;
    }
    try {
        window.sessionStorage.setItem('local_storage_supported', '1');
        const result = window.sessionStorage.getItem('local_storage_supported');
        window.sessionStorage.removeItem('local_storage_supported');
        return result === '1';
    }
    catch (error) {
        return false;
    }
};
class MemoryStorage {
    constructor() {
        this.storage = {};
    }
    getItem(key) {
        return this[key] || null;
    }
    setItem(key, value) {
        this.storage[key] = value;
    }
    removeItem(key) {
        delete this.storage[key];
    }
}
const memoryStorage = typeof window !== 'undefined' ? window.memoryStorage : new MemoryStorage();

const storage = isStorageSupported() ? window.sessionStorage : memoryStorage;
const getItem = (key, defaultValue = null) => {
    const value = storage.getItem(key);
    try {
        return (value && JSON.parse(value)) || defaultValue;
    }
    catch (SyntaxError) {
        return value || defaultValue;
    }
};
const setItem = (key, value) => storage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));
const removeItem = (key) => {
    setItem(key, ''); // Due to some versions of browser bug can't removeItem correctly.
    storage.removeItem(key);
};
/**
 * @param {KEY_SESSION} key - key to retrieve the data
 * @returns {ProviderSession | null} ProviderSession | null
 * @description
 * Get ProviderSession from storage.
 * If the data is expired, will remove the data and return null
 */
const getAccountStorage = (key) => {
    const rawAccountStorage = getItem(key, null);
    if (!rawAccountStorage)
        return null;
    // compare the expiry time of the item with the current time
    if (new Date().getTime() > rawAccountStorage.expiry ||
        rawAccountStorage.v !== SDK_VERSION) {
        removeItem(key);
        return null;
    }
    return rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data;
};
/**
  @param {KEY_SESSION} key - key to store the data
  @param {ProviderSession} data - Only the part of ProviderSession that needs to be updated
  @param {number} expiry - expiry time of the data
*/
const setAccountStorage = (key, data, expiry) => {
    var _a, _b, _c;
    const rawAccountStorage = getItem(key);
    const newAccountStorage = {
        data: {
            code: (data === null || data === void 0 ? void 0 : data.code) || ((_a = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _a === void 0 ? void 0 : _a.code),
            accounts: Object.assign(Object.assign({}, (_b = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _b === void 0 ? void 0 : _b.accounts), data === null || data === void 0 ? void 0 : data.accounts),
            evm: Object.assign(Object.assign({}, (_c = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _c === void 0 ? void 0 : _c.evm), data === null || data === void 0 ? void 0 : data.evm),
        },
        expiry: expiry ||
            (rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.expiry) ||
            new Date().getTime() + LOGIN_PERSISTING_TIME,
        v: SDK_VERSION,
    };
    setItem(key, newAccountStorage);
    return;
};
const getChainAddress = (key, chain) => {
    var _a, _b, _c;
    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {
        removeItem(key);
        return null;
    }
    return ((_c = (_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c[chain]) || null;
};
const setChainAddress = (key, chain, account) => {
    setAccountStorage(key, { accounts: { [chain]: account } });
    return;
};
const removeChainAddress = (key, chain) => {
    setAccountStorage(key, { accounts: { [chain]: undefined } });
    return;
};
const getEvmAddress = (key, chain) => {
    var _a, _b, _c;
    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {
        removeItem(key);
        return null;
    }
    return ((_c = (_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.evm) === null || _c === void 0 ? void 0 : _c[chain]) || null;
};
const setEvmAddress = (key, chain, accounts) => {
    setAccountStorage(key, { evm: { [chain]: accounts } });
    return;
};
const removeAllEvmAddress = (key) => {
    const newAccountStorage = getItem(key);
    if (!newAccountStorage)
        return;
    newAccountStorage.data.evm = {};
    setItem(key, newAccountStorage);
    return;
};

function responseSessionGuard(response, key, disconnectHandler) {
    return __awaiter(this, void 0, void 0, function* () {
        if (response.status === 403 || response.status === 401) {
            if (disconnectHandler) {
                disconnectHandler();
            }
            removeItem(key);
        }
        if (!response.ok) {
            const data = yield response.json();
            const e = new Error((data === null || data === void 0 ? void 0 : data.message) || 'unknown error');
            e.error_code = data === null || data === void 0 ? void 0 : data.error_code;
            throw e;
        }
        return response.json();
    });
}

const isEmail = (value) => /\S+@\S+\.\S+/.test(value);

var ERROR_MESSAGE;
(function (ERROR_MESSAGE) {
    ERROR_MESSAGE["INVALID_TRANSACTION"] = "Invalid transaction";
    ERROR_MESSAGE["INVALID_TRANSACTIONS"] = "Invalid transactions";
    ERROR_MESSAGE["INVALID_TRANSACTION_VALUE"] = "Transaction params \"value\" should be hex-encoded string";
})(ERROR_MESSAGE || (ERROR_MESSAGE = {}));

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.char